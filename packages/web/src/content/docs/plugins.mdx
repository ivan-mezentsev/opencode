---
title: Plugins
description: Write your own plugins to extend OpenCode.
---

Plugins allow you to extend OpenCode by hooking into various events and customizing behavior. You can create plugins to add new features, integrate with external services, or modify OpenCode's default behavior.

For examples, check out the [plugins](/docs/ecosystem#plugins) created by the community.

---

## System overview

OpenCode plugins support two entry points:

- `server` (loaded by the OpenCode server from `opencode.json`)
- `tui` (loaded by the terminal UI from `tui.json`)

A plugin can implement either entry point, or both in the same module.

In short:

- **v1 compatibility**: a default exported function is treated as a server plugin.
- **v2 format**: export an object with `server` and/or `tui` keys.
- **TUI plugin scope**: only plugins listed in `tui.json` are loaded for the TUI.

---

## Use a plugin

There are two ways to load plugins.

---

### From local files

Place JavaScript or TypeScript files in the plugin directory.

- `.opencode/plugins/` - Project-level plugins
- `~/.config/opencode/plugins/` - Global plugins

Files in these directories are automatically loaded at startup.

---

### From npm

Specify npm packages in your config file.

```json title="opencode.json"
{
  "$schema": "https://opencode.ai/config.json",
  "plugin": [
    "opencode-helicone-session",
    ["opencode-wakatime", { "project": "vault-33" }],
    ["@my-org/custom-plugin", { "arbitrary": "options" }]
  ]
}
```

Both regular and scoped npm packages are supported.

Browse available plugins in the [ecosystem](/docs/ecosystem#plugins).

---

### How plugins are installed

**npm plugins** are installed automatically using Bun at startup. Packages and their dependencies are cached in `~/.cache/opencode/node_modules/`.

**Local plugins** are loaded directly from the plugin directory. To use external packages, you must create a `package.json` within your config directory (see [Dependencies](#dependencies)), or publish the plugin to npm and [add it to your config](/docs/config#plugins).

---

### Load order

Plugins are loaded from all sources and all hooks run in sequence. When the same plugin appears multiple times, **higher-priority sources win**:

1. Project plugin directory (`.opencode/plugins/`)
2. Project config (`opencode.json`)
3. Global plugin directory (`~/.config/opencode/plugins/`)
4. Global config (`~/.config/opencode/opencode.json`)

Plugins are deduplicated by canonical name (package name or local file name). A higher‑priority local file named `my-plugin.js` will override a lower‑priority npm package named `my-plugin`.

---

### Plugin options from config

Each entry in the `plugin` array can be either:

- A string specifier (package name or file URL), or
- A tuple of `[specifier, options]`

Options are passed as the **second argument** to your plugin initializer (both `server` and `tui`).

---

## Create a plugin

A plugin is a **JavaScript/TypeScript module** that exports one or more plugin
functions. Each function receives a context object and returns a hooks object.

---

### Dependencies

Local plugins and custom tools can use external npm packages. Add a `package.json` to your config directory with the dependencies you need.

```json title=".opencode/package.json"
{
  "dependencies": {
    "shescape": "^2.1.0"
  }
}
```

OpenCode runs `bun install` at startup to install these. Your plugins and tools can then import them.

```ts title=".opencode/plugins/my-plugin.ts"
import { escape } from "shescape"

export const MyPlugin = async (ctx) => {
  return {
    "tool.execute.before": async (input, output) => {
      if (input.tool === "bash") {
        output.args.command = escape(output.args.command)
      }
    },
  }
}
```

---

### Basic structure

```js title=".opencode/plugins/example.js"
export const MyPlugin = async ({ project, client, $, directory, worktree, serverUrl }, options) => {
  console.log("Plugin initialized!")

  return {
    // Hook implementations go here
  }
}
```

The plugin function receives:

- `project`: The current project information.
- `directory`: The current working directory.
- `worktree`: The git worktree path.
- `client`: An opencode SDK client for interacting with the AI.
- `$`: Bun's [shell API](https://bun.com/docs/runtime/shell) for executing commands.
- `serverUrl`: The server URL for the current OpenCode instance.

If you provided options in config, they will be available as the second argument.

---

### TUI plugins

Plugins can also export a `{ server, tui }` object. The server loader executes `server` (same as a normal plugin function). The TUI loader executes `tui` **only** when a TUI is running.

```ts title=".opencode/plugins/example.ts"
export const MyPlugin = {
  server: async (ctx, options) => {
    return {
      // Server hooks
    }
  },
  tui: async (ctx, options) => {
    // TUI-only setup (subscribe to events, call client APIs, etc.)
  },
}
```

TUI input includes:

- `client`: the SDK client for the connected server
- `event`: an event bus for server events
- `url`: server URL
- `directory`: optional working directory

---

### Themes from plugins

Plugins can register one or more TUI themes. Define them as `themes` on the exported object. The TUI will register them as soon as the plugin module is loaded.

```ts title=".opencode/plugins/theme-pack.ts"
export const MyPlugin = {
  themes: {
    "vault-tec": {
      theme: {
        primary: "#5ea9ff",
        secondary: "#7cff7c",
        accent: "#ffd06a",
        // ...all required theme colors
      },
    },
    "vault-tec-light": {
      theme: {
        primary: "#1b4b8a",
        secondary: "#2f8a2f",
        accent: "#a86a00",
      },
    },
  },
  tui: async () => {},
}
```

Plugin themes are added to the theme list. If a theme name already exists (built‑in or custom), the existing theme takes precedence.

---

### TypeScript support

For TypeScript plugins, you can import types from the plugin package:

```ts title="my-plugin.ts" {1}
import type { Plugin } from "@opencode-ai/plugin"

export const MyPlugin: Plugin = async ({ project, client, $, directory, worktree }) => {
  return {
    // Type-safe hook implementations
  }
}
```

---

### Events

Plugins can subscribe to events by implementing the `event` hook. The hook receives `{ event }`, where `event.type` is the event name and `event.data` contains the payload. Here is a list of the different events available.

#### Command Events

- `command.executed`

#### File Events

- `file.edited`
- `file.watcher.updated`

#### Installation Events

- `installation.updated`

#### LSP Events

- `lsp.client.diagnostics`
- `lsp.updated`

#### Message Events

- `message.part.removed`
- `message.part.updated`
- `message.removed`
- `message.updated`

#### Permission Events

- `permission.asked`
- `permission.replied`

#### Server Events

- `server.connected`

#### Session Events

- `session.created`
- `session.compacted`
- `session.deleted`
- `session.diff`
- `session.error`
- `session.idle`
- `session.status`
- `session.updated`

#### Todo Events

- `todo.updated`

#### Shell Events

- `shell.env`

#### Tool Events

- `tool.execute.after`
- `tool.execute.before`

#### TUI Events

- `tui.prompt.append`
- `tui.command.execute`
- `tui.toast.show`
- `tui.session.select`

These fire only when a TUI is connected or a client drives the TUI via `/tui/*` APIs.

---

## Hook reference

Beyond the `event` hook, plugins can implement the following **stable** hooks:

| Hook                     | Purpose                                                                            |
| ------------------------ | ---------------------------------------------------------------------------------- |
| `config`                 | Receives the merged config after startup.                                          |
| `tool`                   | Register custom tools with `@opencode-ai/plugin`.                                  |
| `auth`                   | Provide custom authentication flows for providers.                                 |
| `chat.message`           | Runs when a new user message is received (modify `output.message`/`output.parts`). |
| `chat.params`            | Modify LLM parameters such as temperature, topP, topK, or provider options.        |
| `chat.headers`           | Inject custom request headers for provider calls.                                  |
| `permission.ask`         | Decide whether a permission request should be allowed, denied, or asked.           |
| `command.execute.before` | Modify or inject parts before a slash command executes.                            |
| `tool.execute.before`    | Modify tool arguments before execution.                                            |
| `tool.execute.after`     | Modify tool output metadata/title/text after execution.                            |
| `shell.env`              | Inject environment variables into all shell executions.                            |

---

## Experimental hooks

:::caution
Experimental hooks are unstable and can change without notice.
:::

| Hook                                   | Purpose                                                        |
| -------------------------------------- | -------------------------------------------------------------- |
| `experimental.chat.messages.transform` | Transform the full list of message parts sent to the model.    |
| `experimental.chat.system.transform`   | Modify system prompts before sending them to the model.        |
| `experimental.session.compacting`      | Customize compaction context or replace the compaction prompt. |
| `experimental.text.complete`           | Post-process generated text parts before they are committed.   |

---

## Examples

Here are some examples of plugins you can use to extend opencode.

---

### Send notifications

Send notifications when certain events occur:

```js title=".opencode/plugins/notification.js"
export const NotificationPlugin = async ({ project, client, $, directory, worktree }) => {
  return {
    event: async ({ event }) => {
      // Send notification on session completion
      if (event.type === "session.idle") {
        await $`osascript -e 'display notification "Session completed!" with title "opencode"'`
      }
    },
  }
}
```

We are using `osascript` to run AppleScript on macOS. Here we are using it to send notifications.

:::note
If you’re using the OpenCode desktop app, it can send system notifications automatically when a response is ready or when a session errors.
:::

---

### .env protection

Prevent opencode from reading `.env` files:

```javascript title=".opencode/plugins/env-protection.js"
export const EnvProtection = async ({ project, client, $, directory, worktree }) => {
  return {
    "tool.execute.before": async (input, output) => {
      if (input.tool === "read" && output.args.filePath.includes(".env")) {
        throw new Error("Do not read .env files")
      }
    },
  }
}
```

---

### Inject environment variables

Inject environment variables into all shell execution (AI tools and user terminals):

```javascript title=".opencode/plugins/inject-env.js"
export const InjectEnvPlugin = async () => {
  return {
    "shell.env": async (input, output) => {
      output.env.MY_API_KEY = "secret"
      output.env.PROJECT_ROOT = input.cwd
    },
  }
}
```

---

### Custom tools

Plugins can also add custom tools to opencode:

```ts title=".opencode/plugins/custom-tools.ts"
import { type Plugin, tool } from "@opencode-ai/plugin"

export const CustomToolsPlugin: Plugin = async (ctx) => {
  return {
    tool: {
      mytool: tool({
        description: "This is a custom tool",
        args: {
          foo: tool.schema.string(),
        },
        async execute(args, context) {
          const { directory, worktree } = context
          return `Hello ${args.foo} from ${directory} (worktree: ${worktree})`
        },
      }),
    },
  }
}
```

The `tool` helper creates a custom tool that opencode can call. It takes a Zod schema function and returns a tool definition with:

- `description`: What the tool does
- `args`: Zod schema for the tool's arguments
- `execute`: Function that runs when the tool is called

Your custom tools will be available to opencode alongside built-in tools.

---

### Logging

Use `client.app.log()` instead of `console.log` for structured logging:

```ts title=".opencode/plugins/my-plugin.ts"
export const MyPlugin = async ({ client }) => {
  await client.app.log({
    body: {
      service: "my-plugin",
      level: "info",
      message: "Plugin initialized",
      extra: { foo: "bar" },
    },
  })
}
```

Levels: `debug`, `info`, `warn`, `error`. See [SDK documentation](https://opencode.ai/docs/sdk) for details.

---

### Compaction hooks

Customize the context included when a session is compacted:

```ts title=".opencode/plugins/compaction.ts"
import type { Plugin } from "@opencode-ai/plugin"

export const CompactionPlugin: Plugin = async (ctx) => {
  return {
    "experimental.session.compacting": async (input, output) => {
      // Inject additional context into the compaction prompt
      output.context.push(`
## Custom Context

Include any state that should persist across compaction:
- Current task status
- Important decisions made
- Files being actively worked on
`)
    },
  }
}
```

The `experimental.session.compacting` hook fires before the LLM generates a continuation summary. Use it to inject domain-specific context that the default compaction prompt would miss.

You can also replace the compaction prompt entirely by setting `output.prompt`:

```ts title=".opencode/plugins/custom-compaction.ts"
import type { Plugin } from "@opencode-ai/plugin"

export const CustomCompactionPlugin: Plugin = async (ctx) => {
  return {
    "experimental.session.compacting": async (input, output) => {
      // Replace the entire compaction prompt
      output.prompt = `
You are generating a continuation prompt for a multi-agent swarm session.

Summarize:
1. The current task and its status
2. Which files are being modified and by whom
3. Any blockers or dependencies between agents
4. The next steps to complete the work

Format as a structured prompt that a new agent can use to resume work.
`
    },
  }
}
```

When `output.prompt` is set, it completely replaces the default compaction prompt. The `output.context` array is ignored in this case.
